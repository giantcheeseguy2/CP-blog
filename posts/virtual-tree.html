<html> <head> <link rel="stylesheet" href="../css/tags.css"> <link rel="stylesheet" href="../highlight/styles/default.min.css"> <script src="../highlight/highlight.min.js"></script> <script>hljs.highlightAll();</script> <link rel="stylesheet" href="../css/blog.css"> <link rel="stylesheet" href="../css/navbar.css"> <link rel="stylesheet" href="../css/searchbar.css"> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script> <title>Oursaco Blog | Virtual Tree (Tutorial)</title> </head> <body style="margin:0;"> <div class="navbar"> <img src="../images/logo.jpg" class="logo"> <div class="title"><b>Oursaco</b> Blog</div> <button class="button" onclick="window.location.href='../index.html'"><a href="../index.html">Home</a></button> <button class="button" onclick="window.location.href='../about.html'"><a href="../about.html">About</a></button> <button class="button" onclick="window.location.href='../links.html'"><a href="../links.html">Links</a></button> </div> <div style="width:100%;height:15%;"></div> <div class="blog"><h1>Virtual Tree (Tutorial)</h1>
<div style="font-family:Helvetica; font-size:15px; text-align:center; padding:10px;">4-22-2023</div></div> <div class="tag-container"><div class="tag"><p> virtual tree</p></div><div class="tag"><p> template</p></div></div> <div class="blog"><hr />
<h2>What is a virtual tree</h2>
<p>Given a tree with \(N\) nodes and a subset of \(K\) nodes, we want to construct a new tree that will maintain the relative structure of the \(K\) nodes. Define relevant nodes to be any node that is the lca of any pair of nodes in our subset (including the nodes themselves). The virtual tree will keep all relevant nodes and compress the remaining nodes into edges between relevant nodes.</p>
<h1>Virtual tree algorithm</h1>
<p>First of all, there will always be at most \(2 \cdot K\) relevant nodes (consider the full binary tree case). Define \(dfn[i]\) to be the dfs order of \(i\), or the first time \(i\) is visited by a dfs. Also, assume that the root of the tree is always a relevant node for convenience.</p>
<p>Lets try to simulate a dfs like process on the relevant nodes. We will have a monotonic stack of nodes sorted by increasing \(dfn\). Lets say \(a\) is the top of our stack, \(b\) is the next node we are considering, and \(c\) is their lca.</p>
<p>Pop the stack while the top has a larger \(dfn\) value and then add \(c\) to the top if it does not already exist. Add \(b\) after \(c\) and go to process the next node. This is linear with \(O(1)\) lca. We will add edges between relevant nodes as we pop them out of the stack. There will be an edge from the node popped and the next node in the stack. Some path query algorithm can be used to compress nodes on a path into a single edge.</p>
<h2>Code</h2>
<p>Implementation left as an exercise to the reader.</p>
</div> </body> </html>