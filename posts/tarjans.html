<html> <head> <link rel="stylesheet" href="../css/tags.css"> <link rel="stylesheet" href="../highlight/styles/default.min.css"> <script src="../highlight/highlight.min.js"></script> <script>hljs.highlightAll();</script> <link rel="stylesheet" href="../css/blog.css"> <link rel="stylesheet" href="../css/navbar.css"> <link rel="stylesheet" href="../css/searchbar.css"> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script> <title>Oursaco Blog | Tarjan's Algorithm (Template)</title> </head> <body style="margin:0;"> <div class="navbar"> <img src="../images/logo.jpg" class="logo"> <div class="title"><b>Oursaco</b> Blog</div> <button class="button" onclick="window.location.href='../index.html'"><a href="../index.html">Home</a></button> <button class="button" onclick="window.location.href='../about.html'"><a href="../about.html">About</a></button> <button class="button" onclick="window.location.href='../links.html'"><a href="../links.html">Links</a></button> </div> <div style="width:100%;height:15%;"></div> <div class="blog"><h1>Tarjan's Algorithm (Template)</h1>
<div style="font-family:Helvetica; font-size:15px; text-align:center; padding:10px;">11-30-2022</div></div> <div class="tag-container"><div class="tag"><p> template</p></div><div class="tag"><p> scc</p></div></div> <div class="blog"><hr />
<h2>Problem Statement</h2>
<p>We want to be able to find to find all strongly connected components (all pairs of nodes have a path to each other) in both directed and undirected graphs. In undirected graphs, there must be two edge disjoint paths between every pair of nodes.</p>
<h2>Solution</h2>
<p>Lets construct a dfs tree for the graph and assign each node \(x\) its discovery time, \(dfn[x]\). The idea is to store \(low[x]\) for every node \(x\), the smallest discovery time of any reachable nodes. If \(low[x] = dfn[x]\), then node \(x\) will be the &quot;root&quot; of its strongly connected component. To reconstruct the components, we can just keep a stack of the active nodes during the dfs and pop out the stack after processing node \(x\). Nodes that are added to the stack after \(x\) are always reachable by \(x\), and if they are already contained in their own strongly connected component, then they will have been removed by the time we return to \(x\). Therefore, if \(low[x] = dfn[x]\) after processing \(x\), then all nodes in the stack that have been visited after \(x\) should be in \(x\)'s component.</p>
<h2>Code</h2>
<h3>Directed</h3>
<p>Note for the directed case, we need to make sure that \(i\) is inside the stack with \(in[i]\), since we don't want to consider \(i\) if its already been found to be in a strongly connected component. It is guranteed that if a node has been visited and is not in the stack, then it is already in a strongly connected component.</p>
<pre><code class="language-c++">void dfs(int x){
	dfn[x] = low[x] = ++tim;
    in[x] = true;
	st.push(x);
	for(int i : g[x]){
		if(!dfn[i]){
			dfs(i);
			low[x] = min(low[x], low[i]);
		} else if(in[i]) low[x] = min(low[x], low[i]);
	}
	if(low[x] == dfn[x]){
		while(st.top() != x){
            in[s.top()] = false;
			comp[st.top()] = x;
			st.pop();
		}
        in[x] = false;
        comp[x] = x;
		st.pop();
	}
}
</code></pre>
<h3>Undirected</h3>
<p>There is no need to gurantee that \(i\) is in the stack if it has been visited before, since the edges are undirected. So if a node has been visited before, and it is visited again, then they are all part of the same strongly connected component. We should also store the id of the parent edge, since we don't want to be able to go back through the same edge.</p>
<pre><code class="language-c++">void dfs(int x, int p = -1){
    dfn[x] = low[x] = ++tim;
    s.push(x);
    for(pii i : g[x]){
        if(i.ss == p) continue;
        if(!dfn[i.ff]){
            dfs(i.ff, i.ss);
            low[x] = min(low[x], low[i.ff]);
        } else low[x] = min(low[x], low[i.ff]);
    }
    if(low[x] == dfn[x]){
		while(st.top() != x){
			comp[st.top()] = x;
			st.pop();
		}
        comp[x] = x;
		st.pop();
	}
}
</code></pre>
</div> </body> </html>